<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æµå¼é—®ç­”ï¼ˆVue2 + ElementUIï¼‰</title>
    <!-- å¼•å…¥ Vue2 CDN -->
    <script src="https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js"></script>
    <!-- å¼•å…¥ ElementUI CSS CDN -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/element-ui@2.15.14/lib/theme-chalk/index.css">
    <!-- å¼•å…¥ ElementUI JS CDN -->
    <script src="https://cdn.jsdelivr.net/npm/element-ui@2.15.14/lib/index.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background-color: #f5f7fa;
            padding: 20px;
        }
        .chat-container {
            max-width: 1000px;
            margin: 0 auto;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.08);
            padding: 20px;
        }
        .chat-messages {
            height: 600px;
            overflow-y: auto;
            padding: 10px;
            border: 1px solid #ebeef5;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        .message-item {
            margin-bottom: 16px;
            max-width: 80%;
        }
        .user-message {
            margin-left: auto;
        }
        .ai-message {
            margin-right: auto;
        }
        .message-bubble {
            padding: 12px 16px;
            border-radius: 8px;
            word-wrap: break-word;
        }
        .user-bubble {
            background-color: #409eff;
            color: #fff;
        }
        .ai-bubble {
            background-color: #f5f5f5;
            color: #333;
        }
        .think-content {
            color: #666;
            font-style: italic;
            margin-bottom: 8px;
            padding-left: 12px;
            border-left: 3px solid #ccc;
            font-size: 14px;
        }
        .answer-content {
            font-size: 15px;
            line-height: 1.6;
        }
        .query-input {
            display: flex;
            gap: 10px;
        }
    </style>
</head>
<body>
<div id="app" class="chat-container">
    <!-- å¯¹è¯æ¡†æ ‡é¢˜ -->
    <h3 style="text-align: center; margin-bottom: 20px; color: #333;">æµå¼é—®ç­”åŠ©æ‰‹</h3>

    <!-- èŠå¤©æ¶ˆæ¯åˆ—è¡¨ -->
    <div class="chat-messages" ref="chatMessages">
        <div
                v-for="(msg, index) in messageList"
                :key="index"
                :class="['message-item', msg.type === 'user' ? 'user-message' : 'ai-message']"
        >
            <div class="message-bubble" :class="msg.type === 'user' ? 'user-bubble' : 'ai-bubble'">
                <!-- AI æ¶ˆæ¯ï¼šåŒºåˆ†æ€è€ƒå†…å®¹å’Œæ­£æ–‡å†…å®¹ -->
                <div v-if="msg.type === 'ai'">
                    <div class="think-content" v-if="msg.thinkContent">ğŸ’¡ æ€è€ƒè¿‡ç¨‹ï¼š{{ msg.thinkContent }}</div>
                    <div class="answer-content">âœ… å›ç­”å†…å®¹ï¼š{{ msg.answerContent }}</div>
                </div>
                <!-- ç”¨æˆ·æ¶ˆæ¯ï¼šç›´æ¥å±•ç¤º -->
                <div v-else>{{ msg.content }}</div>
            </div>
        </div>
    </div>

    <!-- è¾“å…¥æŸ¥è¯¢æ¡† -->
    <div class="query-input">
        <el-input
                v-model="query"
                placeholder="è¯·è¾“å…¥æŸ¥è¯¢é—®é¢˜ï¼ˆä¾‹å¦‚ï¼šçƒ­å¸¦é›¨æ—æ°”å€™ï¼‰"
                @keyup.enter="sendQuery"
                clearable
                style="flex: 1;"
        ></el-input>
        <el-button
                type="primary"
                @click="sendQuery"
                :disabled="isLoading"
        >
            <i class="el-icon-send" v-if="!isLoading"></i>
            <i class="el-icon-loading" v-if="isLoading"></i>
            {{ isLoading ? 'æ­£åœ¨åŠ è½½...' : 'å‘é€æŸ¥è¯¢' }}
        </el-button>
    </div>
</div>

<script>
    // åˆå§‹åŒ– Vue2 å®ä¾‹
    new Vue({
        el: '#app',
        data() {
            return {
                // æŸ¥è¯¢è¾“å…¥æ¡†
                query: '',
                // èŠå¤©æ¶ˆæ¯åˆ—è¡¨
                messageList: [],
                // åŠ è½½çŠ¶æ€ï¼ˆé˜²æ­¢é‡å¤å‘é€è¯·æ±‚ï¼‰
                isLoading: false,
                // æ€è€ƒæ¨¡å¼æ ‡è®°ï¼ˆ0:åˆå§‹, 1:æ€è€ƒä¸­, 2:æ­£æ–‡æ¨¡å¼ï¼‰
                thinkStage: 0,
                // æ‰“å­—æœºæ•ˆæœç›¸å…³ï¼šç¼“å­˜æœªæ¸²æŸ“çš„å†…å®¹ã€å®šæ—¶å™¨
                typewriterCache: {
                    think: '',    // æ€è€ƒå†…å®¹ç¼“å­˜
                    answer: '',   // æ­£æ–‡å†…å®¹ç¼“å­˜
                    timer: null   // æ‰“å­—æœºå®šæ—¶å™¨
                },
                // æœªå¤„ç†çš„æµå¼æ•°æ®ç¼“å­˜ï¼ˆè§£å†³è·¨chunkæˆªæ–­é—®é¢˜ï¼‰
                unprocessedContent: ''
            };
        },
        methods: {
            /**
             * å‘é€æŸ¥è¯¢è¯·æ±‚ï¼ˆå¯¹æ¥ SpringBoot3 Flux æµå¼æ¥å£ï¼‰
             */
            async sendQuery() {
                // æ ¡éªŒè¾“å…¥
                if (!this.query.trim() || this.isLoading) return;
                const queryContent = this.query.trim();

                // 1. æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°åˆ—è¡¨
                this.messageList.push({
                    type: 'user',
                    content: queryContent
                });

                // 2. æ·»åŠ ç©ºçš„AIæ¶ˆæ¯ï¼ˆç”¨äºåç»­æ‰“å­—æœºæ¸²æŸ“ï¼‰
                const aiMsgIndex = this.messageList.push({
                    type: 'ai',
                    thinkContent: '',
                    answerContent: ''
                }) - 1;

                // 3. é‡ç½®çŠ¶æ€
                this.query = '';
                this.isLoading = true;
                this.thinkStage = 0;
                this.unprocessedContent = '';
                clearInterval(this.typewriterCache.timer);
                this.typewriterCache = { think: '', answer: '', timer: null };

                // 4. æ»šåŠ¨åˆ°æœ€æ–°æ¶ˆæ¯
                this.scrollToBottom();

                try {
                    // 5. å‘é€ GET è¯·æ±‚å¯¹æ¥ SpringBoot æµå¼æ¥å£
                    const response = await fetch(`/api/dify/stream?query=${encodeURIComponent(queryContent)}`, {
                        method: 'GET',
                        headers: {
                            'Accept': 'text/event-stream, application/json'
                        }
                    });

                    // 6. æ ¡éªŒå“åº”çŠ¶æ€
                    if (!response.ok) throw new Error(`è¯·æ±‚å¤±è´¥ï¼š${response.status} ${response.statusText}`);
                    if (!response.body) throw new Error('å“åº”ä¸æ”¯æŒæµå¼æ•°æ®');

                    // 7. å¤„ç† ReadableStream æµå¼æ•°æ®
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder('utf-8');

                    while (true) {
                        const { done, value } = await reader.read();
                        // æµå¼æ•°æ®ç»“æŸ
                        if (done) break;

                        // 8. è§£ç äºŒè¿›åˆ¶æ•°æ®å¹¶å¤„ç†
                        const chunk = decoder.decode(value, { stream: true });
                        this.processStreamChunk(chunk, aiMsgIndex);
                    }

                    // 9. å¤„ç†æœ€åå‰©ä½™çš„ç¼“å­˜æ•°æ®ï¼ˆé˜²æ­¢æœ«å°¾æ•°æ®ä¸¢å¤±ï¼‰
                    if (this.unprocessedContent) {
                        // å…ˆè¿‡æ»¤ data: å‰ç¼€ï¼Œå†å¤„ç†æ ‡ç­¾
                        const filteredContent = this.removeDataPrefix(this.unprocessedContent);
                        if (filteredContent) {
                            this.handleTagAndStage(filteredContent, aiMsgIndex);
                        }
                        this.unprocessedContent = '';
                    }

                } catch (error) {
                    // å¼‚å¸¸å¤„ç†ï¼šæ›´æ–°AIæ¶ˆæ¯æç¤ºé”™è¯¯
                    this.messageList[aiMsgIndex] = {
                        type: 'ai',
                        thinkContent: '',
                        answerContent: `âŒ æŸ¥è¯¢å¤±è´¥ï¼š${error.message}`
                    };
                    console.error('æµå¼è¯·æ±‚å¼‚å¸¸ï¼š', error);
                } finally {
                    // 10. ç»“æŸåŠ è½½çŠ¶æ€ï¼Œæ¸…ç†å®šæ—¶å™¨
                    this.isLoading = false;
                    clearInterval(this.typewriterCache.timer);
                    // ç¡®ä¿æ‰€æœ‰ç¼“å­˜å†…å®¹éƒ½æ¸²æŸ“å®Œæˆ
                    this.flushTypewriterCache(aiMsgIndex);
                }
            },

            /**
             * å¤„ç†æµå¼æ•°æ®å—ï¼ˆè§£å†³è·¨chunkã€æ•°æ®æˆªæ–­é—®é¢˜ï¼Œå…ˆè¿‡æ»¤data:å†å¤„ç†æ ‡ç­¾ï¼‰
             * @param {string} chunk å•ä¸ªæµå¼æ•°æ®å—
             * @param {number} aiMsgIndex AIæ¶ˆæ¯åœ¨åˆ—è¡¨ä¸­çš„ç´¢å¼•
             */
            processStreamChunk(chunk, aiMsgIndex) {
                // 1. æ‹¼æ¥æœªå¤„ç†çš„ç¼“å­˜æ•°æ®ï¼ˆè§£å†³è·¨chunkæˆªæ–­ï¼‰
                const fullContent = this.unprocessedContent + chunk;
                this.unprocessedContent = '';

                // 2. æŒ‰è¡Œæ‹†åˆ†ï¼ˆSpringBoot Flux é€šå¸¸ä»¥ \n åˆ†éš”æ•°æ®ï¼‰
                const lines = fullContent.split('\n');

                // 3. éå†æ‰€æœ‰è¡Œï¼Œå¤„ç†æœ‰æ•ˆæ•°æ®
                lines.forEach((line, index) => {
                    let trimmedLine = line.trim();
                    if (!trimmedLine) return;

                    // 4. æœ€åä¸€è¡Œå¯èƒ½æ˜¯æˆªæ–­æ•°æ®ï¼Œå­˜å…¥ç¼“å­˜ç­‰å¾…ä¸‹ä¸€ä¸ªchunk
                    if (index === lines.length - 1) {
                        this.unprocessedContent += trimmedLine;
                        return;
                    }

                    // 5. ç¬¬ä¸€æ­¥ï¼šè¿‡æ»¤ data: å‰ç¼€ï¼ˆä»…å¤„ç†å¼€å¤´ï¼Œä¿ç•™æ ‡ç­¾å®Œæ•´ï¼‰
                    const filteredContent = this.removeDataPrefix(trimmedLine);
                    if (!filteredContent) return;

                    // 6. ç¬¬äºŒæ­¥ï¼šå¤„ç†æ ‡ç­¾å’Œæ€è€ƒé˜¶æ®µï¼ˆæ ¸å¿ƒï¼šå…ˆè¿‡æ»¤å†åˆ†æ ‡ç­¾ï¼Œä¸ç ´å<think>ï¼‰
                    this.handleTagAndStage(filteredContent, aiMsgIndex);
                });
            },

            /**
             * å·¥å…·æ–¹æ³•ï¼šä»…ç§»é™¤å¼€å¤´çš„ data: å‰ç¼€ï¼ˆä¿ç•™<think>æ ‡ç­¾å®Œæ•´æ€§ï¼Œæ ¸å¿ƒä¿®å¤ç‚¹ï¼‰
             * @param {string} content å¾…è¿‡æ»¤çš„å†…å®¹
             * @returns {string} ç§»é™¤å¼€å¤´data:åçš„çº¯å†…å®¹ï¼ˆä¿ç•™<think>å’Œ</think>ï¼‰
             */
            removeDataPrefix(content) {
                if (!content) return '';
                // 1. ä»…å¤„ç†å¼€å¤´çš„ data: ï¼ˆä¸è½¬å°å†™ï¼Œé¿å…ç ´å<think>æ ‡ç­¾ï¼Œå…¼å®¹Data:/DATA:ï¼‰
                const dataPrefixRegex = /^data:/i;
                // 2. æ›¿æ¢å¼€å¤´çš„å•ä¸ª/å¤šä¸ªè¿ç»­ data: å‰ç¼€
                let processed = content.replace(/^(data:)+/i, '').trim();
                // 3. ä¸å¤„ç†å†…å®¹ä¸­é—´çš„ data:ï¼Œé¿å…ç ´åæ ‡ç­¾å’Œæ­£å¸¸æ–‡æœ¬
                return processed;
            },

            /**
             * æ ¸å¿ƒä¿®å¤ï¼šå…ˆåŒºåˆ†<think>/</think>æ ‡ç­¾ï¼Œå†æ›´æ–°ç¼“å­˜ï¼ˆç¡®ä¿é˜¶æ®µåˆ‡æ¢å‡†ç¡®ï¼‰
             * @param {string} content è¿‡æ»¤data:åçš„æœ‰æ•ˆå†…å®¹
             * @param {number} aiMsgIndex AIæ¶ˆæ¯åœ¨åˆ—è¡¨ä¸­çš„ç´¢å¼•
             */
            handleTagAndStage(content, aiMsgIndex) {
                // ä¸´æ—¶å­˜å‚¨å½“å‰å†…å®¹ï¼Œé¿å…ç›´æ¥ä¿®æ”¹åŸå†…å®¹å¯¼è‡´æ ‡ç­¾ä¸¢å¤±
                let currentContent = content;

                // æƒ…å†µ1ï¼šåˆå§‹çŠ¶æ€ â†’ åŒ¹é…<think>ï¼Œè¿›å…¥æ€è€ƒæ¨¡å¼ï¼ˆä¼˜å…ˆå¤„ç†ï¼Œç¡®ä¿æ ‡ç­¾å®Œæ•´ï¼‰
                if (this.thinkStage === 0 && currentContent.includes('<think>')) {
                    const parts = currentContent.split('<think>');
                    if (parts.length > 1) {
                        // æ ‡ç­¾å‰çš„å†…å®¹ â†’ æ­£æ–‡ç¼“å­˜ï¼ˆå·²è¿‡æ»¤data:ï¼Œçº¯æ–‡æœ¬ï¼‰
                        if (parts[0].trim()) {
                            this.typewriterCache.answer += parts[0];
                        }
                        // åˆ‡æ¢åˆ°æ€è€ƒæ¨¡å¼
                        this.thinkStage = 1;
                        // æ ‡ç­¾åçš„å†…å®¹ â†’ å­˜å…¥ä¸´æ—¶å†…å®¹ï¼Œåç»­ä½œä¸ºæ€è€ƒå†…å®¹å¤„ç†
                        currentContent = parts.slice(1).join('<think>').trim();
                        // è‹¥æ— åç»­å†…å®¹ï¼Œç›´æ¥è¿”å›
                        if (!currentContent) return;
                    }
                }

                // æƒ…å†µ2ï¼šæ€è€ƒæ¨¡å¼ â†’ åŒ¹é…</think>ï¼Œé€€å‡ºæ€è€ƒæ¨¡å¼ï¼ˆå…¶æ¬¡å¤„ç†ï¼Œç¡®ä¿é˜¶æ®µåˆ‡æ¢ï¼‰
                if (this.thinkStage === 1 && currentContent.includes('</think>')) {
                    const parts = currentContent.split('</think>');
                    if (parts.length > 1) {
                        // æ ‡ç­¾å‰çš„å†…å®¹ â†’ æ€è€ƒç¼“å­˜ï¼ˆå·²è¿‡æ»¤data:ï¼Œçº¯æ–‡æœ¬ï¼‰
                        if (parts[0].trim()) {
                            this.typewriterCache.think += parts[0];
                        }
                        // åˆ‡æ¢åˆ°æ­£æ–‡æ¨¡å¼
                        this.thinkStage = 2;
                        // æ ‡ç­¾åçš„å†…å®¹ â†’ å­˜å…¥ä¸´æ—¶å†…å®¹ï¼Œåç»­ä½œä¸ºæ­£æ–‡å†…å®¹å¤„ç†
                        currentContent = parts.slice(1).join('</think>').trim();
                        // è‹¥æ— åç»­å†…å®¹ï¼Œç›´æ¥è¿”å›
                        if (!currentContent) return;
                    }
                }

                // æƒ…å†µ3ï¼šæ ¹æ®å½“å‰é˜¶æ®µï¼Œè¿½åŠ åˆ°å¯¹åº”ç¼“å­˜ï¼ˆæœ€åå¤„ç†ï¼Œç¡®ä¿å†…å®¹ä¸æ··æ·†ï¼‰
                if (this.thinkStage === 1) {
                    // æ€è€ƒæ¨¡å¼ï¼šè¿½åŠ åˆ°æ€è€ƒç¼“å­˜
                    this.typewriterCache.think += currentContent;
                } else {
                    // åˆå§‹/æ­£æ–‡æ¨¡å¼ï¼šè¿½åŠ åˆ°æ­£æ–‡ç¼“å­˜
                    this.typewriterCache.answer += currentContent;
                }

                // å¯åŠ¨æ‰“å­—æœºæ•ˆæœï¼ˆç¡®ä¿åªæœ‰ä¸€ä¸ªå®šæ—¶å™¨åœ¨è¿è¡Œï¼‰
                this.startTypewriter(aiMsgIndex);
            },

            /**
             * æ‰“å­—æœºæ•ˆæœå®ç°ï¼ˆé€å­—æ¸²æŸ“ï¼Œæ¨¡æ‹Ÿäººå·¥è¾“å…¥ï¼‰
             * @param {number} aiMsgIndex AIæ¶ˆæ¯åœ¨åˆ—è¡¨ä¸­çš„ç´¢å¼•
             */
            startTypewriter(aiMsgIndex) {
                if (this.typewriterCache.timer) return;

                // æ‰“å­—æœºé€Ÿåº¦ï¼ˆå¯è°ƒæ•´ï¼Œæ•°å€¼è¶Šå°é€Ÿåº¦è¶Šå¿«ï¼‰
                const typeSpeed = 30;

                this.typewriterCache.timer = setInterval(() => {
                    const aiMsg = this.messageList[aiMsgIndex];
                    let hasUpdate = false;

                    // 1. æ¸²æŸ“æ€è€ƒå†…å®¹ï¼ˆé€å­—è¿½åŠ ï¼Œä¼˜å…ˆäºæ­£æ–‡ï¼‰
                    if (this.typewriterCache.think) {
                        aiMsg.thinkContent += this.typewriterCache.think[0];
                        this.typewriterCache.think = this.typewriterCache.think.slice(1);
                        hasUpdate = true;
                    }

                    // 2. æ€è€ƒå†…å®¹æ¸²æŸ“å®Œæˆåï¼Œå†æ¸²æŸ“æ­£æ–‡å†…å®¹ï¼ˆç¡®ä¿åˆ†ç¦»ä¸æ··æ·†ï¼‰
                    if (!this.typewriterCache.think && this.typewriterCache.answer) {
                        aiMsg.answerContent += this.typewriterCache.answer[0];
                        this.typewriterCache.answer = this.typewriterCache.answer.slice(1);
                        hasUpdate = true;
                    }

                    // 3. æ— æ›´æ–°å†…å®¹æ—¶ï¼Œæ¸…é™¤å®šæ—¶å™¨
                    if (!hasUpdate) {
                        clearInterval(this.typewriterCache.timer);
                        this.typewriterCache.timer = null;
                    }

                    // 4. æ»šåŠ¨åˆ°æœ€æ–°æ¶ˆæ¯
                    this.scrollToBottom();

                }, typeSpeed);
            },

            /**
             * åˆ·æ–°æ‰“å­—æœºç¼“å­˜ï¼ˆç¡®ä¿æ‰€æœ‰å†…å®¹éƒ½æ¸²æŸ“å®Œæˆï¼Œæ— æ®‹ç•™ï¼‰
             * @param {number} aiMsgIndex AIæ¶ˆæ¯åœ¨åˆ—è¡¨ä¸­çš„ç´¢å¼•
             */
            flushTypewriterCache(aiMsgIndex) {
                const aiMsg = this.messageList[aiMsgIndex];
                // è¿½åŠ å‰©ä½™çš„æ€è€ƒå†…å®¹å’Œæ­£æ–‡å†…å®¹ï¼ˆä¸¥æ ¼åˆ†ç¦»ï¼‰
                aiMsg.thinkContent += this.typewriterCache.think;
                aiMsg.answerContent += this.typewriterCache.answer;
                // æ¸…ç©ºç¼“å­˜
                this.typewriterCache.think = '';
                this.typewriterCache.answer = '';
                // æ»šåŠ¨åˆ°åº•éƒ¨
                this.scrollToBottom();
            },

            /**
             * æ»šåŠ¨åˆ°æ¶ˆæ¯åˆ—è¡¨åº•éƒ¨
             */
            scrollToBottom() {
                this.$nextTick(() => {
                    const chatMessages = this.$refs.chatMessages;
                    if (chatMessages) {
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    }
                });
            }
        },
        destroyed() {
            // ç»„ä»¶é”€æ¯æ—¶ï¼Œæ¸…ç†å®šæ—¶å™¨
            clearInterval(this.typewriterCache.timer);
        }
    });
</script>
</body>
</html>